        const minuteStamp = getCurrentMinuteStamp();
        const baseEvent = {
            teamKey,
            minute: minuteStamp,
            playerId: player?.id,
            playerName: player?.name || t('Jogador'),
        };

        if (statToUpdate === 'goals') {
            const assister = assisterId ? findPlayerById(assisterId) : null;
            const assistName = assister ? (assister.name || null) : null;
            recordTimelineEvent({
                type: 'goal',
                assistName,
                ...baseEvent,
            });
            if (assister) {
                // Also log an explicit assist event entry
                recordTimelineEvent({
                    type: 'assist',
                    teamKey,
                    minute: minuteStamp,
                    playerId: assister.id,
                    playerName: assister.name || t('Jogador'),
                });
            }
        } else if (statToUpdate === 'ownGoals') {
            recordTimelineEvent({
                type: 'ownGoal',
                ...baseEvent,
            });
        } else {
            const typeMap = {
                assists: 'assist',
                dribbles: 'dribble',
                tackles: 'tackle',
                failures: 'failure',
                saves: 'save',
            };
            const normalizedType = typeMap[statToUpdate] || statToUpdate;
            recordTimelineEvent({
                type: normalizedType,
                ...baseEvent,
            });
        }

        setIsAssistModalOpen(false);
        setGoalScorerInfo(null);
        setPlayerForAction(null);
    };
    
    const handleInitiateSubstitution = (player) => {
        setPlayerToSubstitute(player);
        setIsSubModalOpen(true);
        setPlayerForAction(null);
    };

    const handleConfirmSubstitution = (playerOut, playerIn) => {
        let substitutionTeamKey = null;
        const newTeams = deepClone(allTeams);
        let posOut;
        let posIn;

        newTeams.forEach((team, tIndex) => {
            if (Array.isArray(team)) team.forEach((p, pIndex) => {
                if (p?.id === playerOut.id) posOut = { tIndex, pIndex };
                if (p?.id === playerIn.id) posIn = { tIndex, pIndex };
            });
        });

        if (posOut) substitutionTeamKey = posOut.tIndex === 0 ? 'teamA' : 'teamB';

        if (posOut && posIn) {
            // Swap players between positions without introducing duplicates
            const tempOut = newTeams[posOut.tIndex][posOut.pIndex];
            const tempIn = newTeams[posIn.tIndex][posIn.pIndex];
            newTeams[posOut.tIndex][posOut.pIndex] = tempIn;
            newTeams[posIn.tIndex][posIn.pIndex] = tempOut;
        }

        if (onTeamsChange) onTeamsChange(newTeams);

        if (substitutionTeamKey) {
            recordTimelineEvent({
                type: 'substitution',
                minute: getCurrentMinuteStamp(),
                teamKey: substitutionTeamKey,
                playerOutName: playerOut.name,
                playerInName: playerIn.name,
            });
        }
        setIsSubModalOpen(false);
        setPlayerToSubstitute(null);
    };

    const teamsInPlay = {
        teamA: allTeams[0] || [],
        teamB: allTeams[1] || []
    };

    const benchIndex = Math.max(2, Number(numberOfTeams) || 2);
    const benchPlayers = (allTeams[benchIndex] || []).filter(p => p);
    const waitingTeams = useMemo(() => {
        return (allTeams || []).slice(benchIndex + 1).filter(t => Array.isArray(t) && t.length > 0);
    }, [allTeams, benchIndex]);

    const availableSubsForPlayer = React.useMemo(() => {
        // Restrict substitutions to bench players only to avoid cross-team duplication
        return benchPlayers;
    }, [benchPlayers]);

    const handleAddPlayerToTeam = (player, targetIndex) => {
        if (!player || typeof targetIndex !== 'number') return;
        const newTeams = deepClone(allTeams);

        // Remove player from any team/bench they might be in
        newTeams.forEach((team, tIndex) => {
            if (!Array.isArray(team)) return;
            const idx = team.findIndex(p => p?.id === player.id);
            if (idx >= 0) team.splice(idx, 1);
        });
        // Ensure target team exists
        while (newTeams.length <= targetIndex) newTeams.push([]);
        newTeams[targetIndex].push(player);
        if (onTeamsChange) onTeamsChange(newTeams);
    };
    
    return (
        <>
            <SubstitutionModal 
                isOpen={isSubModalOpen} 
                onClose={() => setIsSubModalOpen(false)} 
                playerOut={playerToSubstitute} 
                availableSubs={availableSubsForPlayer} 
                onConfirm={handleConfirmSubstitution}
                t={t}
            />
            <LiveMatchTracker 
                teams={teamsInPlay}
                score={score}
                timeLeft={timeLeft}
                isPaused={isPaused}
                history={history}
                playerStats={playerStats}
                playerForAction={playerForAction}
                isAssistModalOpen={isAssistModalOpen}
                teammates={teammates}
                onTogglePause={handleTogglePause}
                onAddMinute={handleAddMinute}
                onUndo={handleUndo}
                onEndMatch={() => {
                    try { localStorage.removeItem(liveStateKey); } catch {}
                    const finishedAt = new Date().toISOString();
                    const startedAtIso = new Date(startedAtRef.current).toISOString();
                    const finalTeams = {
                        teamA: [...(teamsInPlay.teamA || [])],
                        teamB: [...(teamsInPlay.teamB || [])],
                    };
                    const finalStats = deepClone(playerStats || {});
                    const finalEvents = deepClone(eventTimeline || []);
                    const resultsPerPlayer = (() => {
                        const map = {};
                        const a = finalTeams.teamA || [];
                        const b = finalTeams.teamB || [];
                        const aScore = Number(score?.teamA || 0);
                        const bScore = Number(score?.teamB || 0);
                        const winnerKey = aScore > bScore ? 'teamA' : (bScore > aScore ? 'teamB' : null);
                        a.forEach(p => { if (!p?.id) return; map[p.id] = winnerKey === 'teamA' ? 'win' : (winnerKey === 'teamB' ? 'loss' : 'draw'); });
                        b.forEach(p => { if (!p?.id) return; map[p.id] = winnerKey === 'teamB' ? 'win' : (winnerKey === 'teamA' ? 'loss' : 'draw'); });
                        return map;
                    })();
                    onMatchEnd({
                        teams: finalTeams,
                        score: { ...score },
                        playerStats: finalStats,
                        events: finalEvents,
                        resultsPerPlayer,
                        startedAt: startedAtIso,
                        endedAt: finishedAt,
                    });
                }}
                onPlayerAction={(player, teamKey) => setPlayerForAction({ player, teamKey })}
                onGoal={handleGoal}
                onSelectAssister={handleSelectAssister}
                onInitiateSubstitution={handleInitiateSubstitution}
                timelineEvents={eventTimeline}
                openCreatePlayer={onCreatePlayer}
                openBench={() => setShowBench(true)}
                openQueue={() => setShowQueue(true)}
                disableFab={isQuickAddOpen}
                t={t}
            />


            {/* Bench side panel */}
            {showBench && (
                <div className="fixed right-4 top-20 bottom-4 z-40 w-80 rounded-xl border border-indigo-500/40 bg-[#0b1220]/95 p-4 overflow-hidden shadow-2xl">
                    <div className="flex items-center justify-between mb-3">
                        <h3 className="text-sm font-bold text-indigo-200">Jogadores disponíveis</h3>
                        <button onClick={() => setShowBench(false)} className="text-slate-300 hover:text-white">✕</button>
                    </div>
                    <div className="h-[calc(100%-2rem)] overflow-y-auto space-y-2 pr-1">
                        {benchPlayers.length === 0 ? (
                            <p className="text-xs text-slate-400">Nenhum jogador disponível.</p>
                        ) : (
                            benchPlayers.map((p) => (
                                <div key={p.id} className="flex items-center justify-between gap-2 rounded-lg border border-indigo-500/20 bg-indigo-900/30 px-3 py-2">
                                    <span className="text-sm font-semibold text-white truncate">{p.name}</span>
                                    <div className="flex items-center gap-2">
                                        <button
                                            onClick={() => handleAddPlayerToTeam(p, 0)}
                                            className="text-xs rounded-md bg-green-600 hover:bg-green-500 text-white px-2 py-1"
                                            title={`Adicionar ao ${t('Time A')}`}
                                        >A</button>
                                        <button
                                            onClick={() => handleAddPlayerToTeam(p, 1)}
                                            className="text-xs rounded-md bg-blue-600 hover:bg-blue-500 text-white px-2 py-1"
                                            title={`Adicionar ao ${t('Time B')}`}
                                        >B</button>
                                    </div>
                                </div>
                            ))
                        )}
                    </div>
                </div>
            )}

            {showBench && (
                <ReservePanel
                    isOpen={showBench}
                    onClose={() => setShowBench(false)}
                    reserves={benchPlayers}
                    teamLabels={(allTeams || []).map((_, idx) => (
                        idx === 0 ? t('Time A') : idx === 1 ? t('Time B') : idx === benchIndex ? 'Reservas' : `Fila ${idx - 2}`
                    ))}
                    excludeIndices={[benchIndex]}
                    onAddToTeam={handleAddPlayerToTeam}
                    title="Jogadores disponíveis"
                />
            )}

            {/* Queue side panel */}
            {showQueue && (
                <div className="fixed left-4 top-20 bottom-4 z-40 w-96 rounded-xl border border-purple-500/40 bg-[#0b1220]/95 p-4 overflow-hidden shadow-2xl">
                    <div className="flex items-center justify-between mb-3">
                        <h3 className="text-sm font-bold text-purple-200">Times na fila</h3>
                        <button onClick={() => setShowQueue(false)} className="text-slate-300 hover:text-white">✕</button>
                    </div>
                    <div className="mb-3">
                        <span className="text-xs text-slate-300">Próximo:</span>
